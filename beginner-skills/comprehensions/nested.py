# A 3 by 3 matrix would be represented by the following list:

[ [1, 0, 0],
  [0, 1, 0],
  [0, 0, 1] ]

# The above matrix can be generated by the following comprehension:

[ [ 1 if item_idx == row_idx else 0 for item_idx in range(0, 3)] for row_idx in range(0, 3)]


# Using zip() and dealing with two or more elements at a time:
['%s=%s' % (n, v) for n, v in zip(self.all_names, self)]

# Multiple types (auto unpacking of a tuple):
[f(v) for (n, f), v in zip(cls.all_slots, values)]

# Using Nested IF with Python List Comprehension

new_list = [x for x in range(50) if x%2 == 0 if x%5 == 0]
print(new_list)

# Nested Lists in Python List Comprehension
# display the multiplication tables of 4, 5, and 6.using regular nested for loops,
for x in range(4,7):
    for y in range(1, 11):
print(f"{x}*{y}={x*y}")

# using Python list comprehension
table = [[x*y for y in range(1,11)] for x in range(4,7)]
print(table)


# Nested Dictionary Comprehension
 nested_dict = {'first': {'a': 1}, 'second':{'b':2}}
 floated_dict = {outer_k: {float(inner_v) for (inner_k, inner_v) in outer_v.items()}
 for (outer_k, outer_v) in nested_dict.items()}

 print(float_dict)

 # with a nested for loop:

 nested_dict = {'first': {'a':1}, 'second':{'b':2}}

 for (outer_k, outer_v) in nested_dict.items():
     for (inner_k, inner_v) in outer_v.items():
         outer_v.update({inner_k: float(inner_v)})
 nested_dict.update({outer_k:outer_v})

 print(nested_dict)
